<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deep Live Cam - Client</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-group {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .control-group h3 {
            margin-bottom: 15px;
            color: #4ecdc4;
        }

        .server-config {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
        }

        .server-config input {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 14px;
        }

        .server-config input::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            margin: 5px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #ff6b6b, #ee5a6f);
            color: white;
        }

        .btn-success {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            color: white;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        button:disabled {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.5);
            cursor: not-allowed;
            transform: none;
        }

        .upload-area {
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            margin: 15px 0;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-area:hover,
        .upload-area.dragover {
            border-color: #4ecdc4;
            background: rgba(78, 205, 196, 0.1);
        }

        .upload-area input[type="file"] {
            display: none;
        }

        .upload-preview {
            max-width: 150px;
            max-height: 150px;
            border-radius: 8px;
            margin: 10px auto;
            display: none;
        }

        .status {
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #4ecdc4;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }

        .status.error {
            border-left-color: #ff6b6b;
            background: rgba(255, 107, 107, 0.1);
        }

        .status.success {
            border-left-color: #4ecdc4;
            background: rgba(78, 205, 196, 0.1);
        }

        .video-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .video-box {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            overflow: hidden;
            position: relative;
        }

        .video-box h3 {
            text-align: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            margin: 0;
        }

        video, canvas {
            width: 100%;
            height: 400px;
            object-fit: cover;
            background: #000;
        }

        .fps-counter {
            position: absolute;
            top: 50px;
            right: 15px;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
        }

        .connection-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff6b6b;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }

        .connection-indicator.connected {
            background: #4ecdc4;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-box {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #4ecdc4;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.8;
            margin-top: 5px;
        }

        @media (max-width: 768px) {
            .controls {
                grid-template-columns: 1fr;
            }

            .video-container {
                grid-template-columns: 1fr;
            }

            .server-config {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé≠ Deep Live Cam</h1>
            <p>Real-time AI face swapping client</p>
        </div>

        <div class="controls">
            <div class="control-group">
                <h3>üåê Server Connection</h3>
                <div class="server-config">
                    <input type="text" id="serverUrl" placeholder="Server URL (e.g., ws://localhost:8000)"
                           value="ws://localhost:8000">
                    <button class="btn-primary" id="connectBtn">
                        <span class="connection-indicator" id="connectionIndicator"></span>
                        Connect
                    </button>
                </div>
                <button class="btn-secondary" id="testConnectionBtn">Test Connection</button>
                <div class="status" id="connectionStatus">Ready to connect...</div>
            </div>

            <div class="control-group">
                <h3>üì∏ Source Image</h3>
                <div class="upload-area" id="uploadArea">
                    <input type="file" id="sourceImage" accept="image/*">
                    <div class="upload-content">
                        <p>üìÅ Choose file or drag & drop</p>
                        <p style="font-size: 0.8em; opacity: 0.7;">Select face to apply to camera feed</p>
                    </div>
                    <img class="upload-preview" id="imagePreview" alt="Preview">
                </div>
                <div class="status" id="uploadStatus">No source image selected</div>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <h3>üìπ Camera Controls</h3>
                <button class="btn-success" id="startCameraBtn">Start Camera</button>
                <button class="btn-secondary" id="stopCameraBtn" disabled>Stop Camera</button>
                <button class="btn-primary" id="startProcessingBtn" disabled>Start Processing</button>
                <button class="btn-secondary" id="stopProcessingBtn" disabled>Stop Processing</button>
            </div>

            <div class="control-group">
                <h3>üìä Statistics</h3>
                <div class="stats">
                    <div class="stat-box">
                        <div class="stat-value" id="fpsValue">0</div>
                        <div class="stat-label">FPS</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="latencyValue">0</div>
                        <div class="stat-label">Latency (ms)</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="framesValue">0</div>
                        <div class="stat-label">Frames Processed</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="video-container">
            <div class="video-box">
                <h3>üì∑ Camera Input</h3>
                <video id="localVideo" autoplay muted></video>
                <div class="fps-counter" id="inputFps">0 FPS</div>
            </div>
            <div class="video-box">
                <h3>üé≠ Processed Output</h3>
                <canvas id="processedCanvas"></canvas>
                <div class="fps-counter" id="outputFps">0 FPS</div>
            </div>
        </div>
    </div>

    <script>
        class DeepLiveCamClient {
            constructor() {
                this.websocket = null;
                this.mediaStream = null;
                this.isProcessing = false;
                this.serverUrl = 'ws://localhost:8000';
                this.stats = {
                    fps: 0,
                    latency: 0,
                    framesProcessed: 0,
                    lastFrameTime: 0
                };

                this.initializeElements();
                this.setupEventListeners();
                this.startStatsUpdate();
            }

            initializeElements() {
                // Get DOM elements
                this.elements = {
                    serverUrl: document.getElementById('serverUrl'),
                    connectBtn: document.getElementById('connectBtn'),
                    testConnectionBtn: document.getElementById('testConnectionBtn'),
                    connectionStatus: document.getElementById('connectionStatus'),
                    connectionIndicator: document.getElementById('connectionIndicator'),

                    uploadArea: document.getElementById('uploadArea'),
                    sourceImage: document.getElementById('sourceImage'),
                    imagePreview: document.getElementById('imagePreview'),
                    uploadStatus: document.getElementById('uploadStatus'),

                    startCameraBtn: document.getElementById('startCameraBtn'),
                    stopCameraBtn: document.getElementById('stopCameraBtn'),
                    startProcessingBtn: document.getElementById('startProcessingBtn'),
                    stopProcessingBtn: document.getElementById('stopProcessingBtn'),

                    localVideo: document.getElementById('localVideo'),
                    processedCanvas: document.getElementById('processedCanvas'),

                    fpsValue: document.getElementById('fpsValue'),
                    latencyValue: document.getElementById('latencyValue'),
                    framesValue: document.getElementById('framesValue'),
                    inputFps: document.getElementById('inputFps'),
                    outputFps: document.getElementById('outputFps')
                };

                this.ctx = this.elements.processedCanvas.getContext('2d');
                this.elements.processedCanvas.width = 640;
                this.elements.processedCanvas.height = 480;
            }

            setupEventListeners() {
                // Server connection
                this.elements.connectBtn.addEventListener('click', () => this.toggleConnection());
                this.elements.testConnectionBtn.addEventListener('click', () => this.testConnection());
                this.elements.serverUrl.addEventListener('change', (e) => {
                    this.serverUrl = e.target.value;
                });

                // File upload
                this.elements.sourceImage.addEventListener('change', () => this.handleImageUpload());
                this.setupDragAndDrop();

                // Camera controls
                this.elements.startCameraBtn.addEventListener('click', () => this.startCamera());
                this.elements.stopCameraBtn.addEventListener('click', () => this.stopCamera());
                this.elements.startProcessingBtn.addEventListener('click', () => this.startProcessing());
                this.elements.stopProcessingBtn.addEventListener('click', () => this.stopProcessing());
            }

            setupDragAndDrop() {
                const uploadArea = this.elements.uploadArea;

                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });

                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });

                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        this.elements.sourceImage.files = files;
                        this.handleImageUpload();
                    }
                });

                uploadArea.addEventListener('click', () => {
                    this.elements.sourceImage.click();
                });
            }

            async testConnection() {
                this.updateStatus('Testing connection...', 'info');

                try {
                    const httpUrl = this.serverUrl.replace('ws://', 'http://').replace('wss://', 'https://');
                    const response = await fetch(`${httpUrl}/health`);
                    const data = await response.json();

                    this.updateStatus(`‚úì Server is online - Mode: ${data.mode}, Clients: ${data.clients}`, 'success');
                } catch (error) {
                    this.updateStatus(`‚úó Connection failed: ${error.message}`, 'error');
                }
            }

            toggleConnection() {
                if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                    this.disconnect();
                } else {
                    this.connect();
                }
            }

            connect() {
                try {
                    this.updateStatus('Connecting to server...', 'info');
                    this.websocket = new WebSocket(`${this.serverUrl}/ws`);

                    this.websocket.onopen = () => {
                        this.updateStatus('‚úì Connected to server', 'success');
                        this.elements.connectBtn.textContent = 'Disconnect';
                        this.elements.connectionIndicator.classList.add('connected');
                        this.elements.startProcessingBtn.disabled = false;
                    };

                    this.websocket.onmessage = (event) => {
                        if (event.data instanceof Blob) {
                            this.handleProcessedFrame(event.data);
                        }
                    };

                    this.websocket.onclose = () => {
                        this.updateStatus('Disconnected from server', 'error');
                        this.elements.connectBtn.textContent = 'Connect';
                        this.elements.connectionIndicator.classList.remove('connected');
                        this.elements.startProcessingBtn.disabled = true;
                        this.stopProcessing();
                    };

                    this.websocket.onerror = (error) => {
                        this.updateStatus(`Connection error: ${error.message}`, 'error');
                    };

                } catch (error) {
                    this.updateStatus(`Failed to connect: ${error.message}`, 'error');
                }
            }

            disconnect() {
                if (this.websocket) {
                    this.websocket.close();
                }
                this.stopProcessing();
            }

            async handleImageUpload() {
                const file = this.elements.sourceImage.files[0];
                if (!file) return;

                // Show preview
                const reader = new FileReader();
                reader.onload = (e) => {
                    this.elements.imagePreview.src = e.target.result;
                    this.elements.imagePreview.style.display = 'block';
                };
                reader.readAsDataURL(file);

                // Upload to server
                const formData = new FormData();
                formData.append('file', file);

                try {
                    const httpUrl = this.serverUrl.replace('ws://', 'http://').replace('wss://', 'https://');
                    const response = await fetch(`${httpUrl}/upload-source`, {
                        method: 'POST',
                        body: formData
                    });

                    if (response.ok) {
                        this.updateUploadStatus('‚úì Source image uploaded successfully', 'success');
                    } else {
                        const error = await response.text();
                        this.updateUploadStatus(`‚úó Upload failed: ${error}`, 'error');
                    }
                } catch (error) {
                    this.updateUploadStatus(`‚úó Upload error: ${error.message}`, 'error');
                }
            }

            async startCamera() {
                try {
                    this.mediaStream = await navigator.mediaDevices.getUserMedia({
                        video: { width: 640, height: 480 }
                    });
                    this.elements.localVideo.srcObject = this.mediaStream;

                    this.elements.startCameraBtn.disabled = true;
                    this.elements.stopCameraBtn.disabled = false;
                    this.updateStatus('‚úì Camera started', 'success');
                } catch (error) {
                    this.updateStatus(`‚úó Camera error: ${error.message}`, 'error');
                }
            }

            stopCamera() {
                if (this.mediaStream) {
                    this.mediaStream.getTracks().forEach(track => track.stop());
                    this.mediaStream = null;
                }
                this.elements.localVideo.srcObject = null;
                this.elements.startCameraBtn.disabled = false;
                this.elements.stopCameraBtn.disabled = true;
                this.stopProcessing();
                this.updateStatus('Camera stopped', 'info');
            }

            startProcessing() {
                if (!this.mediaStream || !this.websocket || this.websocket.readyState !== WebSocket.OPEN) {
                    this.updateStatus('‚úó Need camera and server connection', 'error');
                    return;
                }

                this.isProcessing = true;
                this.elements.startProcessingBtn.disabled = true;
                this.elements.stopProcessingBtn.disabled = false;
                this.updateStatus('‚úì Processing started', 'success');
                this.processFrames();
            }

            stopProcessing() {
                this.isProcessing = false;
                this.elements.startProcessingBtn.disabled = false;
                this.elements.stopProcessingBtn.disabled = true;
                this.updateStatus('Processing stopped', 'info');
            }

            processFrames() {
                if (!this.isProcessing) return;

                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = this.elements.localVideo.videoWidth;
                canvas.height = this.elements.localVideo.videoHeight;

                context.drawImage(this.elements.localVideo, 0, 0);

                canvas.toBlob((blob) => {
                    if (blob && this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                        this.stats.lastFrameTime = Date.now();
                        this.websocket.send(blob);
                        this.stats.framesProcessed++;
                    }

                    // Schedule next frame (target 30 FPS)
                    setTimeout(() => this.processFrames(), 33);
                }, 'image/jpeg', 0.8);
            }

            handleProcessedFrame(blob) {
                const now = Date.now();
                const latency = now - this.stats.lastFrameTime;
                this.stats.latency = latency;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        this.ctx.drawImage(img, 0, 0, this.elements.processedCanvas.width, this.elements.processedCanvas.height);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(blob);
            }

            startStatsUpdate() {
                setInterval(() => {
                    this.elements.fpsValue.textContent = this.stats.fps;
                    this.elements.latencyValue.textContent = this.stats.latency;
                    this.elements.framesValue.textContent = this.stats.framesProcessed;
                }, 1000);

                // FPS calculation
                let frameCount = 0;
                setInterval(() => {
                    this.stats.fps = frameCount;
                    frameCount = 0;

                    // Reset frame count every second
                    const observer = new MutationObserver(() => frameCount++);
                    observer.observe(this.elements.processedCanvas, { attributes: true });
                }, 1000);
            }

            updateStatus(message, type = 'info') {
                this.elements.connectionStatus.textContent = message;
                this.elements.connectionStatus.className = `status ${type}`;
            }

            updateUploadStatus(message, type = 'info') {
                this.elements.uploadStatus.textContent = message;
                this.elements.uploadStatus.className = `status ${type}`;
            }
        }

        // Initialize the client when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new DeepLiveCamClient();
        });
    </script>
</body>
</html>